//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System;
//namespace UtilCSharp
//{
	public class BodyNode
	{
		/** quaternion read from body tracking node */
		private Quaternion rawQuaternion;
		/** quaternion aligned with user body */
		private Quaternion alignedQuaternion;
		/** quaternion initial aligned with user body */
		private Quaternion initialQuaternion;
		/** Reversed quaternion of initial aligned with user body */
		private Quaternion initialQuaternionReversed;

		private static bool isCalibrated = false;
		private Transform attachedObjectTrans;
		//constant quaternion used to rotate the left arm 180 degree around z axis to become right arm
        //ie. right arm need the quaternion to be (0, 0, -1, 0)
        //left arm need it to be (0,0,0,1)
        private Quaternion flipQuaternion = new Quaternion(0, 0, 0, 1);
        //slerp speed of the bone
        private float speed = 18;
		public BodyNode (Transform gameobjTrans, Quaternion flipQ)
		{
			rawQuaternion = new Quaternion(0, 0, 0, 1);
			alignedQuaternion = new Quaternion(0, 0, 0, 1);
			initialQuaternion = new Quaternion(0, 0, 0, 1);
			initialQuaternionReversed = new Quaternion(0, 0, 0, 1);
            attachedObjectTrans = gameobjTrans;
            flipQuaternion = flipQ;
			
		}
        /**Function to set the flipQuaternion*/
        public void setFlipQuaternion(float x, float y, float z, float w) { 
            flipQuaternion = new Quaternion (x, y, z, w);
        }
		/** set current body tracking node quaternion as the initial quaternion. */
		public  void setRawAsInitial(Quaternion cameraRotation) {
			initialQuaternion = rawQuaternion;
			initialQuaternionReversed = cameraRotation * Quaternion.Inverse(initialQuaternion);
			isCalibrated = true;
			calculateAlignedQuaternion();
		}
		/**Function called by the implementing class to attach to a real Transform*/
		public void setAttachedObject(Transform gameobj){
			attachedObjectTrans = gameobj;
		}
		/**
	 * calculate and update the aligned quaternion by multiplying it by the
	 * inverse of the initial quaternion. <br/>
	 * ie, Aligned = TnitialReversed x Raw
	 */
		public void calculateAlignedQuaternion() {
		alignedQuaternion = initialQuaternionReversed * rawQuaternion*flipQuaternion;
		}
		
		/** set raw quaternion x,y,z,w */
		public void setRawQuaternion(float x, float y, float z, float w) {
			rawQuaternion.Set(x,y,z,w);
			// do the initial calibration
			if (!isCalibrated) {
				//setRawAsInitial();
			}
			calculateAlignedQuaternion();
		}
	/**Function called by the implementing class to update the roation 
	 * of the attached Transform*/
		public void updateObjRoation(){
            //attachedObjectTrans.transform.rotation = alignedQuaternion;
            float donePercentage = Mathf.Min(1F, Time.deltaTime * speed);
            attachedObjectTrans.transform.rotation = Quaternion.Slerp(attachedObjectTrans.transform.rotation, alignedQuaternion, donePercentage);
		}
	}
//}

